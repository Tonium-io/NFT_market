
/**
 * This file was generated by TONDev.
 * TONDev is a part of TON OS (see http://ton.dev).
 */
pragma ton-solidity >= 0.35.0;
pragma AbiHeader expire;
pragma AbiHeader pubkey;
import "./NFTPair.sol";
import "./NFTAuction.sol";
import "./interfaces.sol";
contract Controller {
    // Errors
    uint constant ACCESS_DENIED = 101;
    uint constant NOT_ENOUGH_MONEY = 102;

    uint public client;
    uint public lockedMoney = 0;
    address[] public root_wallets;
    address[] public wallets;
    mapping(address => address) public m_wallets;

    modifier onlyClient {
        require(msg.pubkey() == client,
            ACCESS_DENIED);
        tvm.accept();
        _;
    }

    modifier onlyExchanger {
        require(msg.pubkey() == tvm.pubkey(),
            ACCESS_DENIED);
        tvm.accept();
        _;
    }

    modifier onlyRootWallets {
        require(search(root_wallets,msg.sender),ACCESS_DENIED);
        tvm.accept();
        _;
    }
    

    constructor(uint public_key) public {
        // Check that contract's public key is set
        require(tvm.pubkey() != 0, 101);
        // Check that message has signature (msg.pubkey() is not zero) and
        // message is signed with the owner's private key
        require(msg.pubkey() == tvm.pubkey(), 102);
        // The current smart contract agrees to buy some gas to finish the
        // current transaction. This actions required to process external
        // messages, which bring no value (henceno gas) with themselves.
        tvm.accept();

        client = public_key;
    }

    function search(address[] _array, address _wallet) private pure returns (bool){
        for(uint i = 0; i < _array.length; i++) {
            if(_array[i] == _wallet) {
                return true;
            }
        }
        return false;
    }

    function buyNFT(address pair, uint128 price) onlyClient public{
        NFTPair(pair).sell{value:price,bounce:true}(client);
    }
    function createNFTWallet_callback(address value0) onlyRootWallets public {
        m_wallets[msg.sender] = value0;
        wallets.push(value0);
    }
    function deployNFT(address root_token) onlyClient public {
        root_wallets.push(root_token);
        RootTokenContractNF(root_token).deployWallet_response{value:1  ton, flag:64, callback: Controller.createNFTWallet_callback}(0,tvm.pubkey(), 1 ton, address(this)) ;
    }

    function sendNFTToken(address wallet,address dest, uint128 tokenId) onlyClient pure public {
        TONTokenWalletNF(wallet).transfer(dest,tokenId,0);
    }

    function sendValue(address dest, uint128 amount, bool bounce) onlyClient pure public {
        dest.transfer(amount, bounce, 0);
    }
    function createNFTPair(address exchanger, uint128 price, uint64 time) onlyClient public {
        IExchanger(exchanger).createNFTPairCrystall{value:2 ton,flag:1}(price,time,tvm.pubkey());
    }
    function createNFTAuction(address exchanger, uint128 price, uint64 time, uint128 step) onlyClient public {
        IExchanger(exchanger).createNFTAuctionCrystall{value:2 ton,flag:1}(price,time,step,tvm.pubkey());
    }
    function setCode(TvmCell newcode) public pure onlyClient {
		tvm.setcode(newcode);
		tvm.setCurrentCode(newcode);
	}
}
