
/**
 * This file was generated by TONDev.
 * TONDev is a part of TON OS (see http://ton.dev).
 */
pragma ton-solidity >= 0.35.0;
pragma AbiHeader expire;
pragma AbiHeader pubkey;
import "./NFTPair.sol";
import "./NFTAuction.sol";
import "./interfaces.sol";
// This is class that describes you smart contract.
contract Controller {
    // Contract can have an instance variables.
    // In this example instance variable `timestamp` is used to store the time of `constructor` or `touch`
    // function call
    uint128 constant minbalance = 3 ton; 
    uint constant YOU_ARE_NOT_GOD = 101;
    uint constant NOT_ENOUGH_MONEY = 102;

    uint public client;
    uint public lockedMoney = 0;
    address[] public root_wallets;
    address[] public wallets;
    mapping(address => uint128) auction;
    // Contract can have a `constructor` â€“ function that will be called when contract will be deployed to the blockchain.
    // In this example constructor adds current time to the instance variable.
    // All contracts need call tvm.accept(); for succeeded deploy

    modifier onlyClient {
        require(msg.pubkey() == client,
            YOU_ARE_NOT_GOD);
        tvm.accept();
        _;
    }

    modifier onlyExchanger {
        require(msg.pubkey() == tvm.pubkey(),
            YOU_ARE_NOT_GOD);
        tvm.accept();
        _;
    }

    modifier onlyRootWallets {
        require(search(root_wallets,msg.sender),YOU_ARE_NOT_GOD);
        tvm.accept();
        _;
    }
    

    constructor(uint public_key) public {
        // Check that contract's public key is set
        require(tvm.pubkey() != 0, 101);
        // Check that message has signature (msg.pubkey() is not zero) and
        // message is signed with the owner's private key
        require(msg.pubkey() == tvm.pubkey(), 102);
        // The current smart contract agrees to buy some gas to finish the
        // current transaction. This actions required to process external
        // messages, which bring no value (henceno gas) with themselves.
        tvm.accept();

        client = public_key;
    }

    function search(address[] _array, address _wallet) private pure returns (bool){
        for(uint i = 0; i < _array.length; i++) {
            if(_array[i] == _wallet) {
                return true;
            }
        }
        return false;
    }

    function buyNFT(address pair, uint128 price) onlyClient public{
        NFTPair(pair).sell{value:price}(client);
    }
    function createNFTWallet_callback(address value0) onlyRootWallets public {
        wallets.push(value0);
    }
    function deployNFT(address root_token) onlyClient public {
        RootTokenContractNF(root_token).deployWallet_response{value:1  ton, flag:64, callback: Controller.createNFTWallet_callback}(0,tvm.pubkey(), 1 ton, address(this)) ;
        root_wallets.push(root_token);
    }

    function sendNFTToken(address wallet,address dest, uint128 tokenId) onlyClient public {
        TONTokenWalletNF(wallet).transfer(dest,tokenId,0);
    }

    function freezeMoney(address pair, uint128 price) onlyClient public {
        NFTAuction(pair).getBet{value:price,flag:1}(tvm.pubkey());
    }




    // Updates variable `timestamp` with current blockchain time.
    // function touch() external {
    //     // Each function that accepts external message must check that
    //     // message is correctly signed.
    //     require(msg.pubkey() == tvm.pubkey(), 102);
    //     // Tells to the TVM that we accept this message.
    //     tvm.accept();
    //     // Update timestamp
    //     timestamp = now;
    // }

    function sendValue(address dest, uint128 amount, bool bounce) onlyClient public {

        dest.transfer(amount, bounce, 0);
    }
}
